import importlib
import types
import sys
import pytest
from unittest.mock import patch, MagicMock


def make_fake_gpio_module():
    m = types.ModuleType("gpiozero")
    class LED:
        def __init__(self, pin):
            self.pin = pin
            self._value = False
        def on(self):
            self._value = True
        def off(self):
            self._value = False
        @property
        def value(self):
            return self._value
        def close(self):
            pass

    class Button:
        def __init__(self, pin, pull_up=False):
            self.pin = pin
            self._value = False
        @property
        def value(self):
            return self._value
        def close(self):
            pass

    m.LED = LED  # type: ignore[attr-defined]
    m.Button = Button  # type: ignore[attr-defined]
    return m


def make_fake_spidev_module():
    m = types.ModuleType("spidev")
    class SpiDev:
        def __init__(self):
            self.opened = False
            self.max_speed_hz = None
            self.mode = None
        def open(self, bus, device):
            self.opened = True
        def writebytes(self, data):
            pass
        def writebytes2(self, data):
            pass
        def close(self):
            self.opened = False
    m.SpiDev = SpiDev  # type: ignore[attr-defined]
    return m


def install_fake_modules(monkeypatch):
    # install spidev and gpiozero
    sys.modules['spidev'] = make_fake_spidev_module()
    gpio_mod = make_fake_gpio_module()
    # also provide top-level attributes expected by tests (LED, Button)
    sys.modules['gpiozero'] = gpio_mod


def test_raspberry_selection_and_methods(monkeypatch, monkeypatching=None):
    install_fake_modules(monkeypatch)
    # monkeypatch cpuinfo output to include Raspberry
    # Create a fake subprocess.Popen that returns 'Raspberry' in output
    class FakePopen:
        def __init__(self, *args, **kwargs):
            pass
        def communicate(self):
            return ("Raspberry Pi" , None)

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())

    epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

    # ensure implementation has expected attributes
    assert hasattr(epdconfig, 'module_init')
    assert hasattr(epdconfig, 'spi_writebyte')

    # call module_init (non-cleanup path) to exercise SPI open
    epdconfig.module_init(cleanup=False)


def test_jetson_imports_guarded(monkeypatch):
    # Ensure Jetson.GPIO is not present and module still loads
    if 'Jetson' in sys.modules:
        del sys.modules['Jetson']
    if 'Jetson.GPIO' in sys.modules:
        del sys.modules['Jetson.GPIO']

    # Simulate cpuinfo without Raspberry to force Jetson selection path
    class FakePopen2:
        def __init__(self, *args, **kwargs):
            pass
        def communicate(self):
            return ("", None)

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen2())

    epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))
    # module should expose functions even without Jetson.GPIO present
    assert hasattr(epdconfig, 'module_init')
    assert hasattr(epdconfig, 'spi_writebyte')


def test_gpio_operations_raspberry_pi(monkeypatch):
    """Test GPIO operations on Raspberry Pi platform."""
    install_fake_modules(monkeypatch)

    # Mock Raspberry Pi detection
    class FakePopen:
        def communicate(self):
            return ("Raspberry Pi", None)

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())

    epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

    # Test GPIO operations
    epdconfig.digital_write(17, 1)  # RST_PIN on
    epdconfig.digital_write(25, 0)  # DC_PIN off
    epdconfig.digital_write(18, 1)  # PWR_PIN on

    # Test digital read
    busy_value = epdconfig.digital_read(24)  # BUSY_PIN
    assert isinstance(busy_value, (int, bool))


def test_gpio_operations_without_hardware(monkeypatch):
    """Test GPIO operations when hardware libraries are not available."""
    # Don't install fake modules - simulate missing hardware

    # Mock Raspberry Pi detection
    class FakePopen:
        def communicate(self):
            return ("Raspberry Pi", None)

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())

    epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

    # Should not crash when hardware libraries are missing
    epdconfig.digital_write(17, 1)  # RST_PIN on
    epdconfig.digital_write(25, 0)  # DC_PIN off

    # Should return default values when hardware not available
    busy_value = epdconfig.digital_read(24)  # BUSY_PIN
    assert busy_value == 0  # Default when GPIO not available


def test_spi_operations_raspberry_pi(monkeypatch):
    """Test SPI operations on Raspberry Pi platform."""
    install_fake_modules(monkeypatch)

    # Mock Raspberry Pi detection
    class FakePopen:
        def communicate(self):
            return ("Raspberry Pi", None)

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())

    epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

    # Initialize module to set up SPI
    result = epdconfig.module_init(cleanup=False)
    assert result == 0

    # Test SPI operations
    epdconfig.spi_writebyte([0x12, 0x34])
    epdconfig.spi_writebyte2([0x56, 0x78])

    # Test module exit
    epdconfig.module_exit(cleanup=False)


def test_module_init_cleanup_mode(monkeypatch):
    """Test module initialization in cleanup mode."""
    install_fake_modules(monkeypatch)

    # Mock Raspberry Pi detection
    class FakePopen:
        def communicate(self):
            return ("Raspberry Pi", None)

    # Mock DEV_Config library loading
    with patch('ctypes.CDLL') as mock_cdll:
        mock_dev_spi = MagicMock()
        mock_cdll.return_value = mock_dev_spi

        monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())
        monkeypatch.setattr('os.path.exists', lambda path: True)
        monkeypatch.setattr('os.popen', lambda cmd: MagicMock())

        epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

        result = epdconfig.module_init(cleanup=True)
        assert result == 0

        # Verify DEV_SPI methods were called
        mock_dev_spi.DEV_Module_Init.assert_called_once()


def test_module_init_cleanup_mode_library_not_found(monkeypatch):
    """Test module initialization when DEV_Config library is not found."""
    install_fake_modules(monkeypatch)

    # Mock Raspberry Pi detection
    class FakePopen:
        def communicate(self):
            return ("Raspberry Pi", None)

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())
    monkeypatch.setattr('os.path.exists', lambda path: False)  # Library not found

    epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

    with pytest.raises(RuntimeError, match="Cannot find DEV_Config.so"):
        epdconfig.module_init(cleanup=True)


def test_dev_spi_operations(monkeypatch):
    """Test DEV_SPI operations when available."""
    install_fake_modules(monkeypatch)

    # Mock Raspberry Pi detection
    class FakePopen:
        def communicate(self):
            return ("Raspberry Pi", None)

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())

    epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

    # Get the implementation object by accessing the bound method's __self__
    impl = epdconfig.module_init.__self__

    # Mock DEV_SPI as an attribute on the implementation
    mock_dev_spi = MagicMock()
    mock_dev_spi.DEV_SPI_ReadData.return_value = 0x42
    impl.DEV_SPI = mock_dev_spi

    # Test DEV_SPI operations
    epdconfig.DEV_SPI_write([0x12, 0x34])
    epdconfig.DEV_SPI_nwrite([0x56, 0x78])
    result = epdconfig.DEV_SPI_read()

    # Verify calls
    mock_dev_spi.DEV_SPI_SendData.assert_called_with([0x12, 0x34])
    mock_dev_spi.DEV_SPI_SendnData.assert_called_with([0x56, 0x78])
    mock_dev_spi.DEV_SPI_ReadData.assert_called_once()
    assert result == 0x42


def test_dev_spi_operations_no_library(monkeypatch):
    """Test DEV_SPI operations when library is not initialized."""
    install_fake_modules(monkeypatch)

    # Mock Raspberry Pi detection
    class FakePopen:
        def communicate(self):
            return ("Raspberry Pi", None)

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())

    epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

    # DEV_SPI should be None initially (not set by module loading)
    # The actual check happens in the function calls

    # Should raise RuntimeError
    with pytest.raises(RuntimeError, match="DEV_SPI not initialized"):
        epdconfig.DEV_SPI_write([0x12])

    with pytest.raises(RuntimeError, match="DEV_SPI not initialized"):
        epdconfig.DEV_SPI_nwrite([0x34])

    with pytest.raises(RuntimeError, match="DEV_SPI not initialized"):
        epdconfig.DEV_SPI_read()


def test_jetson_platform_operations(monkeypatch):
    """Test operations on Jetson platform."""
    # Mock Jetson detection (no Raspberry in cpuinfo)
    class FakePopen:
        def communicate(self):
            return ("", None)  # No Raspberry detected

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())

    # Mock sysfs library loading
    with patch('ctypes.cdll.LoadLibrary') as mock_load_lib:
        mock_spi = MagicMock()
        mock_load_lib.return_value = mock_spi

        # Mock os.path.exists to return True only for sysfs library, not gpio-x3
        def mock_exists(path):
            if 'sysfs_software_spi.so' in path:
                return True
            elif '/sys/bus/platform/drivers/gpio-x3' in path:
                return False
            return True

        monkeypatch.setattr('os.path.exists', mock_exists)

        # Mock Jetson.GPIO import
        mock_jetson_gpio = MagicMock()
        mock_jetson_gpio.BCM = "BCM"
        mock_jetson_gpio.OUT = "OUT"
        mock_jetson_gpio.IN = "IN"
        mock_jetson_gpio.setmode = MagicMock()
        mock_jetson_gpio.setwarnings = MagicMock()
        mock_jetson_gpio.setup = MagicMock()
        mock_jetson_gpio.output = MagicMock()
        mock_jetson_gpio.cleanup = MagicMock()

        original_import = importlib.import_module
        def mock_import_module(name):
            if name == 'Jetson.GPIO':
                return mock_jetson_gpio
            return original_import(name)

        monkeypatch.setattr('importlib.import_module', mock_import_module)

        epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

        # Test Jetson-specific operations
        result = epdconfig.module_init()
        assert result == 0

        epdconfig.spi_writebyte([0x12])
        epdconfig.spi_writebyte2([0x34, 0x56])

        epdconfig.module_exit()

        # Verify GPIO calls were made
        mock_jetson_gpio.setmode.assert_called_with(mock_jetson_gpio.BCM)


def test_jetson_platform_no_library(monkeypatch):
    """Test Jetson platform when sysfs library is not available."""
    # Mock Jetson detection (no Raspberry in cpuinfo)
    class FakePopen:
        def communicate(self):
            return ("", None)  # No Raspberry detected

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())
    monkeypatch.setattr('os.path.exists', lambda path: False)  # No library found

    epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

    # Should use mock SPI implementation
    result = epdconfig.module_init()
    assert result == 0

    # Should not crash
    epdconfig.spi_writebyte([0x12])
    epdconfig.module_exit()


def test_sunrise_x3_platform(monkeypatch):
    """Test Sunrise X3 platform detection and operations."""
    # Mock Sunrise X3 detection
    class FakePopen:
        def communicate(self):
            return ("", None)  # No Raspberry detected

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())

    # Mock GPIO library for Sunrise X3
    install_fake_modules(monkeypatch)

    # Create a mock Hobot GPIO module
    mock_hobot_gpio = types.ModuleType("Hobot.GPIO")
    mock_hobot_gpio.BCM = "BCM"  # type: ignore[attr-defined]
    mock_hobot_gpio.OUT = "OUT"  # type: ignore[attr-defined]
    mock_hobot_gpio.IN = "IN"  # type: ignore[attr-defined]
    mock_hobot_gpio.output = MagicMock()  # type: ignore[attr-defined]
    mock_hobot_gpio.input = MagicMock(return_value=1)  # type: ignore[attr-defined]
    mock_hobot_gpio.setmode = MagicMock()  # type: ignore[attr-defined]
    mock_hobot_gpio.setwarnings = MagicMock()  # type: ignore[attr-defined]
    mock_hobot_gpio.setup = MagicMock()  # type: ignore[attr-defined]
    mock_hobot_gpio.cleanup = MagicMock()  # type: ignore[attr-defined]

    # Mock the import
    original_import = importlib.import_module
    def mock_import_module(name):
        if name == 'Hobot.GPIO':
            return mock_hobot_gpio
        return original_import(name)

    monkeypatch.setattr('importlib.import_module', mock_import_module)

    # Mock os.path.exists to return True for gpio-x3 path
    def mock_exists(path):
        if '/sys/bus/platform/drivers/gpio-x3' in path:
            return True
        return False

    monkeypatch.setattr('os.path.exists', mock_exists)

    epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

    # Test Sunrise X3 operations
    result = epdconfig.module_init()
    assert result == 0

    # Test GPIO operations
    epdconfig.digital_write(17, 1)
    epdconfig.digital_write(25, 0)

    value = epdconfig.digital_read(24)
    assert isinstance(value, (int, bool))

    epdconfig.module_exit()


def test_delay_ms_functionality(monkeypatch):
    """Test delay_ms timing function."""
    install_fake_modules(monkeypatch)

    # Mock Raspberry Pi detection
    class FakePopen:
        def communicate(self):
            return ("Raspberry Pi", None)

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())

    with patch('time.sleep') as mock_sleep:
        epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

        epdconfig.delay_ms(100)

        mock_sleep.assert_called_once_with(0.1)


def test_module_exit_cleanup_operations(monkeypatch):
    """Test module exit with cleanup operations."""
    install_fake_modules(monkeypatch)

    # Mock Raspberry Pi detection
    class FakePopen:
        def communicate(self):
            return ("Raspberry Pi", None)

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())

    epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

    # Initialize first
    epdconfig.module_init(cleanup=False)

    # Test exit
    epdconfig.module_exit(cleanup=False)

    # Verify GPIO cleanup was called
    # (This would be verified by checking the mock GPIO objects)


def test_platform_detection_edge_cases(monkeypatch):
    """Test platform detection with various edge cases."""
    test_cases = [
        ("Raspberry Pi 4", "RaspberryPi"),
        ("Raspberry Pi Zero", "RaspberryPi"),
        ("Jetson Nano", "JetsonNano"),
        ("", "JetsonNano"),  # Default when no Raspberry detected
    ]

    for cpuinfo_output, expected_platform in test_cases:
        class FakePopen:
            def communicate(self):
                return (cpuinfo_output, None)

        monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())

        epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

        # Verify platform-specific attributes exist
        assert hasattr(epdconfig, 'module_init')
        assert hasattr(epdconfig, 'digital_write')
        assert hasattr(epdconfig, 'digital_read')
        assert hasattr(epdconfig, 'spi_writebyte')


def test_gpio_pin_constants():
    """Test that GPIO pin constants are correctly defined."""
    from display.waveshare_epd.epdconfig import RaspberryPi, JetsonNano, SunriseX3

    # Test Raspberry Pi pin definitions
    rpi = RaspberryPi()
    assert rpi.RST_PIN == 17
    assert rpi.DC_PIN == 25
    assert rpi.CS_PIN == 8
    assert rpi.BUSY_PIN == 24
    assert rpi.PWR_PIN == 18

    # Test Jetson Nano pin definitions
    jetson = JetsonNano()
    assert jetson.RST_PIN == 17
    assert jetson.DC_PIN == 25
    assert jetson.CS_PIN == 8
    assert jetson.BUSY_PIN == 24
    assert jetson.PWR_PIN == 18

    # Test Sunrise X3 pin definitions
    sunrise = SunriseX3()
    assert sunrise.RST_PIN == 17
    assert sunrise.DC_PIN == 25
    assert sunrise.CS_PIN == 8
    assert sunrise.BUSY_PIN == 24
    assert sunrise.PWR_PIN == 18


def test_hardware_import_error_handling(monkeypatch):
    """Test graceful handling when hardware libraries fail to import."""
    # Mock Raspberry Pi detection
    class FakePopen:
        def communicate(self):
            return ("Raspberry Pi", None)

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())

    # Test without installing fake modules - should handle missing libraries gracefully
    epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

    # Should still have basic functionality even with missing libraries
    assert hasattr(epdconfig, 'module_init')
    assert hasattr(epdconfig, 'digital_write')
    assert hasattr(epdconfig, 'digital_read')

    # Test operations when libraries are missing
    epdconfig.digital_write(17, 1)  # Should not crash
    value = epdconfig.digital_read(24)  # Should return default value
    assert value == 0  # Default when GPIO not available


def test_pin_mapping_comprehensive(monkeypatch):
    """Test comprehensive pin mapping for all GPIO operations."""
    install_fake_modules(monkeypatch)

    # Mock Raspberry Pi detection
    class FakePopen:
        def communicate(self):
            return ("Raspberry Pi", None)

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())

    epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

    # Test all pin operations
    pins_to_test = [17, 25, 18, 24]  # RST, DC, PWR, BUSY

    for pin in pins_to_test:
        # Test digital write
        epdconfig.digital_write(pin, 1)
        epdconfig.digital_write(pin, 0)

        # Test digital read
        value = epdconfig.digital_read(pin)
        assert isinstance(value, (int, bool))


def test_jetson_platform_mock_spi_fallback(monkeypatch):
    """Test Jetson platform when sysfs library is not available (uses mock SPI)."""
    # Mock Jetson detection (no Raspberry in cpuinfo)
    class FakePopen:
        def communicate(self):
            return ("", None)  # No Raspberry detected

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())
    monkeypatch.setattr('os.path.exists', lambda path: False)  # No sysfs library

    epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

    # Should use mock SPI implementation
    result = epdconfig.module_init()
    assert result == 0

    # Test SPI operations with mock
    epdconfig.spi_writebyte([0x12])
    epdconfig.module_exit()


def test_jetson_platform_with_hardware_libraries(monkeypatch):
    """Test Jetson platform with full hardware library support."""
    # Mock Jetson detection
    class FakePopen:
        def communicate(self):
            return ("", None)

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())

    # Mock os.path.exists for sysfs library
    def mock_exists(path):
        if 'sysfs_software_spi.so' in path:
            return True
        return False

    monkeypatch.setattr('os.path.exists', mock_exists)

    # Mock Jetson.GPIO
    mock_jetson_gpio = types.ModuleType("Jetson.GPIO")
    mock_jetson_gpio.BCM = "BCM"
    mock_jetson_gpio.OUT = "OUT"
    mock_jetson_gpio.IN = "IN"
    mock_jetson_gpio.setmode = MagicMock()
    mock_jetson_gpio.setwarnings = MagicMock()
    mock_jetson_gpio.setup = MagicMock()
    mock_jetson_gpio.output = MagicMock()
    mock_jetson_gpio.input = MagicMock(return_value=1)
    mock_jetson_gpio.cleanup = MagicMock()

    original_import = importlib.import_module
    def mock_import_module(name):
        if name == 'Jetson.GPIO':
            return mock_jetson_gpio
        return original_import(name)

    monkeypatch.setattr('importlib.import_module', mock_import_module)

    epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

    # Test module operations
    result = epdconfig.module_init()
    assert result == 0

    # Test GPIO operations
    epdconfig.digital_write(17, 1)
    epdconfig.digital_read(24)

    epdconfig.module_exit()


def test_sunrise_x3_platform_operations(monkeypatch):
    """Test Sunrise X3 platform operations."""
    # Mock Sunrise X3 detection
    class FakePopen:
        def communicate(self):
            return ("", None)

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())

    # Mock GPIO libraries for Sunrise X3
    install_fake_modules(monkeypatch)

    # Mock os.path.exists for gpio-x3
    def mock_exists(path):
        if '/sys/bus/platform/drivers/gpio-x3' in path:
            return True
        return False

    monkeypatch.setattr('os.path.exists', mock_exists)

    epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

    # Test module operations
    result = epdconfig.module_init()
    assert result == 0

    # Test GPIO operations
    epdconfig.digital_write(17, 1)
    epdconfig.digital_read(24)

    epdconfig.module_exit()


def test_sunrise_x3_module_exit_flag_handling(monkeypatch):
    """Test Sunrise X3 module exit flag handling."""
    # Mock Sunrise X3 detection
    class FakePopen:
        def communicate(self):
            return ("", None)

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())
    monkeypatch.setattr('os.path.exists', lambda path: '/sys/bus/platform/drivers/gpio-x3' in path)

    install_fake_modules(monkeypatch)

    epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

    # First init should set flag and initialize
    result1 = epdconfig.module_init()
    assert result1 == 0

    # Second init should return 0 without re-initializing (flag prevents it)
    result2 = epdconfig.module_init()
    assert result2 == 0

    # Exit should reset flag
    epdconfig.module_exit()
    # Flag should be reset to 0 after exit


def test_raspberry_pi_cleanup_mode_with_dev_config(monkeypatch):
    """Test Raspberry Pi cleanup mode with DEV_Config library."""
    install_fake_modules(monkeypatch)

    # Mock Raspberry Pi detection
    class FakePopen:
        def communicate(self):
            return ("Raspberry Pi", None)

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())
    monkeypatch.setattr('os.path.exists', lambda path: True)
    monkeypatch.setattr('os.popen', lambda cmd: MagicMock())

    # Mock DEV_Config library
    with patch('ctypes.CDLL') as mock_cdll:
        mock_dev_config = MagicMock()
        mock_cdll.return_value = mock_dev_config

        epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

        result = epdconfig.module_init(cleanup=True)
        assert result == 0

        # Verify DEV_Config was initialized
        mock_dev_config.DEV_Module_Init.assert_called_once()


def test_jetson_digital_operations_without_gpio(monkeypatch):
    """Test Jetson digital operations when GPIO library is not available."""
    # Mock Jetson detection
    class FakePopen:
        def communicate(self):
            return ("", None)

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())
    monkeypatch.setattr('os.path.exists', lambda path: False)

    epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

    # Should not crash when GPIO is None
    epdconfig.digital_write(17, 1)
    value = epdconfig.digital_read(24)
    assert value == 0  # Default value when GPIO not available


def test_spi_configuration(monkeypatch):
    """Test SPI configuration and parameter setting."""
    install_fake_modules(monkeypatch)

    # Mock Raspberry Pi detection
    class FakePopen:
        def communicate(self):
            return ("Raspberry Pi", None)

    monkeypatch.setattr('subprocess.Popen', lambda *a, **k: FakePopen())

    epdconfig = importlib.reload(importlib.import_module('display.waveshare_epd.epdconfig'))

    # Initialize to configure SPI
    epdconfig.module_init(cleanup=False)

    # Verify SPI configuration would be set (mock objects track this)
    # This tests the configuration path even if hardware isn't present



