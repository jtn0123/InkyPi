{% extends "plugin.html" %}

{% block content %}
<div id="units-container" data-units="{{ units }}"></div>

<div class="weather-dashboard ny{% if plugin_settings.variant_C5 == "true" %} variant-c5{% endif %}">

  <div class="main-grid">
    <div class="left-col">
      <div class="big-icon-temp">
        <img class="current-icon" src="{{ current_day_icon }}" alt="Current Weather Icon">
        <div class="current-weather">
          <div class="current-temp">{{ current_temperature }}<span class="temperature-unit">{{ temperature_unit }}</span></div>
          <div class="feels-like">Feels Like {{ feels_like }}{% if units != "standard" %}°{% endif %}</div>
          <div class="min-max">{{ forecast[0].high }}{% if units != "standard" %}°{% endif %} / {{ forecast[0].low }}{% if units != "standard" %}°{% endif %}</div>
        </div>
      </div>

      {% if alerts %}
      <div class="alerts">
        {% for a in alerts[:2] %}
        <div class="alert-pill">{{ a }}</div>
        {% endfor %}
        {% if alerts|length > 2 %}
        <div class="alert-pill alert-overflow">+{{ alerts|length - 2 }} more</div>
        {% endif %}
      </div>
      {% endif %}

      <div class="metrics-grid">
        {% for dp in data_points %}
        <div class="metric">
          <img class="metric-icon" src="{{ dp.icon }}" alt="{{ dp.label }}">
          <div class="metric-text">
            <div class="metric-label">{{ dp.label }}</div>
            <div class="metric-value">{{ dp.measurement }}{% if dp.unit %}<span class="metric-unit">{{ dp.unit }}</span>{% endif %}</div>
          </div>
        </div>
        {% endfor %}
      </div>

      {% if not (plugin_settings.displayForecast and plugin_settings.displayForecast == "true") and (plugin_settings.moonPhase and plugin_settings.moonPhase == "true") %}
      <div class="moon-phase-container">
        <img class="moon-phase-icon" src="{{ forecast[0].moon_phase_icon }}" alt="Moon phase icon">
        <span class="moon-phase-pct">{{ forecast[0].moon_phase_pct }}%</span>
      </div>
      {% endif %}
    </div>

    <div class="right-col">
      <div class="header">
        <div class="title">{{ title }}</div>
        <div class="current-date">{{ current_date }}</div>
      </div>
      {% if plugin_settings.displayForecast and plugin_settings.displayForecast == "true" %}
      {% set days = (plugin_settings.forecastDays | int) %}
      <div class="forecast ny" style="grid-template-columns: repeat({{ days }}, 1fr);">
        {% for day in forecast[1:days + 1] %}
          <div class="forecast-day">
            <div class="forecast-day-name">{{ day.day }}</div>
            <img class="forecast-icon" src="{{ day.icon }}" alt="{{ day.day }} Weather Icon">
            <div class="forecast-temps">
              <span class="high">{{ day.high }}{% if units != "standard" %}°{% endif %}</span> /
              <span class="low">{{ day.low }}{% if units != "standard" %}°{% endif %}</span>
            </div>
            {% if plugin_settings.moonPhase and plugin_settings.moonPhase == "true" %}
            <div class="moon-phase-container">
              <img class="moon-phase-icon" src="{{ day.moon_phase_icon }}" alt="Moon phase icon">
              <span class="moon-phase-pct">{{ day.moon_phase_pct }}%</span>
            </div>
            {% endif %}
          </div>
        {% endfor %}
      </div>
      {% endif %}

      {% if plugin_settings.displayGraph and plugin_settings.displayGraph == "true" %}
      <div class="chart-container ny">
        <canvas id="hourlyTemperatureChart" style="width: 100%; height: 100%;"></canvas>
      </div>
      {% if plugin_settings.displayRefreshTime == "true" %}
      <div class="last-refresh">{{ last_refresh_time }}</div>
      {% endif %}
      {% endif %}
    </div>
  </div>

  
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    const canvas = document.getElementById('hourlyTemperatureChart');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const labels = [{% for hour in hourly_forecast %}"{{ hour.time }}"{% if not loop.last %}, {% endif %}{% endfor %}];
    const temperatures = [{% for hour in hourly_forecast %}{{ hour.temperature }}{% if not loop.last %}, {% endif %}{% endfor %}];
    const precipitation = [{% for hour in hourly_forecast %}{{ (hour.precipitation * 100) | round(0, 'floor') }}{% if not loop.last %}, {% endif %}{% endfor %}];
    const rainRaw = [{% for hour in hourly_forecast %}{{ hour.rain or 0 }}{% if not loop.last %}, {% endif %}{% endfor %}];

    const units = document.getElementById('units-container').dataset.units;
    const rainIn = (units === 'imperial') ? rainRaw : rainRaw.map(v => (Number(v) || 0) / 25.4);

    let minTemp = temperatures.length ? Math.min(...temperatures) : 0;
    let maxTemp = temperatures.length ? Math.max(...temperatures) : 30;

    // Visually emphasize bars when measurable rain is present
    // POP bars: blue with alpha scaled to percent
    const barColors = precipitation.map(p => `rgba(30,80,200,${Math.max(0.15, Math.min(1, (Number(p)||0)/100))})`);

    // Draw a subtle vertical line at "now" (index 0), and annotate min/max
    const nowLine = {
      id: 'nowLine',
      afterDraw(chart) {
        const {ctx, chartArea: {top, bottom}, scales: {x}} = chart;
        if (!x) return;
        const xPos = x.getPixelForValue(0);
        ctx.save();
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(xPos, top);
        ctx.lineTo(xPos, bottom);
        ctx.stroke();
        ctx.restore();
      }
    };

    // Removed explicit min/max labels to reduce clutter

    // Optional midlines (25/50/75%) per variant C2/C3/C4
    const isC2 = ("{{ plugin_settings.variant_C2 }}" === "true");
    const isC3 = ("{{ plugin_settings.variant_C3 }}" === "true");
    const isC4 = ("{{ plugin_settings.variant_C4 }}" === "true");
    const isC5 = ("{{ plugin_settings.variant_C5 }}" === "true");

    const midLines = {
      id: 'midLines',
      afterDraw(chart) {
        const {ctx, scales: {y}, chartArea: {left, right, top, bottom}} = chart;
        if (!y) return;
        // For C5, compute fixed lines from low/high across visible range
        let values;
        if (isC5) {
          const low = Math.round(y.min);
          const high = Math.round(y.max);
          const span = high - low;
          const q25 = Math.round(low + 0.25 * span);
          const q50 = Math.round(low + 0.5 * span);
          const q75 = Math.round(low + 0.75 * span);
          values = [low, q25, q50, q75, high];
        } else {
          values = [0.25, 0.5, 0.75].map(r => y.min + r * (y.max - y.min));
        }
        ctx.save();
        ctx.strokeStyle = 'rgba(0,0,0,0.12)';
        values.forEach((v, idx) => {
          const yp = y.getPixelForValue(v);
          ctx.beginPath();
          if (isC3) {
            ctx.setLineDash([4, 3]);
          } else {
            ctx.setLineDash([]);
          }
          ctx.lineWidth = (isC4 && (!isC5 ? idx === 1 : v === Math.round((Math.round(y.min)+Math.round(y.max))/2))) ? 1.6 : 1;
          ctx.moveTo(left, yp);
          ctx.lineTo(right, yp);
          ctx.stroke();
          // Label each line near right edge
          ctx.setLineDash([]);
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          ctx.font = '11px -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif';
          const label = `${Math.round(v)}°`;
          ctx.textAlign = 'right';
          const yLabel = Math.min(Math.max(yp - 2, top + 10), bottom - 8);
          ctx.fillText(label, left - 6, yLabel);
        });
        ctx.restore();
      }
    };

    // Gradient for the temperature line, recomputed after layout
    const tempGradient = {
      id: 'tempGradient',
      beforeDraw(chart, args, opts) {
        const {ctx, chartArea} = chart;
        if (!chartArea) return;
        // Tone-mapped grayscale for e-ink contrast
        const grad = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
        grad.addColorStop(0, 'rgba(0,0,0,0.55)');
        grad.addColorStop(0.5, 'rgba(0,0,0,0.75)');
        grad.addColorStop(1, 'rgba(0,0,0,0.95)');
        const ds = chart.data.datasets[0];
        ds.borderColor = grad;
      }
    };

    const plugins = [nowLine, tempGradient];
    if (isC2 || isC3 || isC4 || isC5) {
      plugins.push(midLines);
    }

    new Chart(ctx, {
      plugins,
      data: {
        labels,
        datasets: [
          {
            type: 'line',
            label: 'Temp',
            data: temperatures,
            borderColor: 'rgba(0,0,0,0.85)',
            borderWidth: 2.5,
            pointRadius: 0,
            pointHoverRadius: 4,
            pointHoverBackgroundColor: '#000',
            tension: 0.35,
            yAxisID: 'y',
            fill: false,
            spanGaps: true
          },
          {
            type: 'bar',
            label: 'POP %',
            data: precipitation,
            backgroundColor: barColors,
            borderColor: barColors,
            borderWidth: 1,
            borderSkipped: false,
            yAxisID: 'y2',
            barPercentage: 0.65,
            categoryPercentage: 0.88
          }
        ]
      },
      options: {
        animation: false,
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: 'nearest', intersect: false },
        elements: { point: { radius: 0 } },
        scales: {
          y: {
            position: 'left',
            grid: { 
              display: !(isC2 || isC3 || isC4 || isC5), 
              color: 'rgba(0,0,0,0.08)', 
              lineWidth: 1,
              drawTicks: false
            },
            border: { display: false },
            min: minTemp - 2,
            max: maxTemp + 2,
            ticks: {
              callback: (v) => (isC2 || isC3 || isC4 || isC5) ? '' : `${v}°`,
              maxTicksLimit: (isC2 || isC3 || isC4 || isC5) ? 0 : 5,
              color: 'rgba(0,0,0,0.6)',
              font: { size: 11, weight: '400' },
              padding: 8
            }
          },
          y2: {
            position: 'right',
            min: 0,
            max: 100,
            grid: { display: false },
            border: { display: false },
            ticks: {
              callback: (v) => `${v}%`,
              stepSize: 50,
              maxTicksLimit: 3,
              autoSkip: false,
              color: 'rgba(0,0,0,0.6)',
              font: { size: 11, weight: '400' },
              padding: 10
            }
          },
          x: {
            grid: { display: false },
            border: { display: false },
            ticks: { 
              maxTicksLimit: 12,
              callback: (v, i) => (i % 2 === 0 ? labels[i] : ''),
              color: 'rgba(0,0,0,0.6)',
              font: { size: 10, weight: '400' },
              padding: 6
            }
          }
        },
        layout: {
          padding: { left: (isC2 || isC3 || isC4 || isC5) ? 36 : 6, right: 18, top: 6, bottom: 10 }
        },
        plugins: {
          legend: { display: false },
          tooltip: { enabled: false }
        }
      }
    });
  });
</script>
{% endblock %}


